# fm.py

# Converting DX7 patches to Alles commands

def get_patch(patch_number):
	# returns a patch (as in patches.h) from 
    # unpacked.bin generated by dx7db, see https://github.com/bwhitman/learnfm
    f = bytes(open("unpacked.bin", mode="rb").read())
    patch_data = f[patch_number*156:patch_number*156+156]
    #name = ''.join([i if (ord(i) < 128 and ord(i) > 31) else ' ' for i in str(patch_data[145:155])])
    return patch_data

def decode_patch(p):
	def eg_to_adsr_amp(egrate, eglevel):
		def rate_to_ms(rate):
			return (99-rate)*2.5 # 250ms is rate=0, 0ms is rate=99
		# http://www.audiocentralmagazine.com/wp-content/uploads/2012/04/dx7-envelope.png
		# rate seems to be "speed", so higher rate == less time
		# NO idea what the time units are, so going to have to fudge this a bit
		# level is probably exp, but so is our ADSR? 
		(r1,r2,r3,r4) = egrate
		(l1,l2,l3,l4) = eglevel
		A = rate_to_ms(r1)
		D = rate_to_ms(r2) + rate_to_ms(r3)
		R = rate_to_ms(r4)
		S = l3/99.0
		amp = l1 / 99.0
		# we ignore l2 and l4 -- l4 should be 0, and l2 is that weird elbow
		# amp tbh is not really fair here , maybe for the carrier? 
		return ("%d,%d,%f,%d" % (A,D,S,R), amp)


	def output_level_to_amp(byte):
		# Sure could be a exp curve but seems a bit custom
		# https://i.stack.imgur.com/1FQqR.jpg
		if(byte<20): return 0
		if(byte<40): return 0.1/14
		if(byte<50): return 0.25/14
		if(byte<60): return 0.5/14
		if(byte<70): return 1.2/14
		if(byte<80): return 2.75/14
		if(byte<85): return 4./14
		if(byte<90): return 6./14
		if(byte<88): return 6.05/14
		if(byte<89): return 6.1/14
		if(byte<90): return 6.2/14
		if(byte<91): return 6.5/14
		if(byte<92): return 7./14
		if(byte<93): return 8./14
		if(byte<94): return 9./14
		if(byte<95): return 9.5/14
		if(byte<96): return 10./14
		if(byte<97): return 11./14
		if(byte<98): return 12.5/14
		if(byte<99): return 13./14
		return 1.0

	def lfo_wave(byte):
		if(byte == 0): return "triangle"
		if(byte == 1): return "ramp_down"
		if(byte == 2): return "ramp_up"
		if(byte == 3): return "pulse"
		if(byte == 4): return "sine"
		if(byte == 5): return "samplehold"
		return "unknown"
	def curve(byte):
		if(byte==0): return "-lin"
		if(byte==1): return "-exp"
		if(byte==2): return "+exp"
		if(byte==3): return "+lin"
		return "unknown"
	def coarse_fine_fixed_hz(coarse, fine):
		if(coarse==0):
			return 1 + ((fine / 10.0) - 1.0)
		if(coarse==1):
			return 10 + ((fine) - 10.0)
		if(coarse==2):
			return 100 + ((fine * 10.0) - 100.0)
		if(coarse==3):
			return 1000 + ((fine * 100.0) - 1000.0)
		print("fixed coarse > 3")
		return 0
	def coarse_fine_ratio(coarse,fine):
		if(coarse==0):
			return 0.5 + ((fine/200.0) - 0.5)
		return coarse + (fine/100.0)
		

	patch = {}
	ops = []
	# Starts at op 6
	c = 0
	for i in range(5,-1,-1):
		op = {}
		(op["envelope"], op["amp"]) = eg_to_adsr_amp([x for x in p[c:c+4]], [x for x in p[c+4:c+8]])
		c = c + 8
		op["brkpt"] = p[c]
		c = c + 1
		op["leftrightcurves"] = [x for x in p[c:c+4]]
		c = c + 4
		op["kbdratescaling"] = p[c]
		c = c + 1
		op["ampmodsens"] = p[c]
		c = c + 1
		op["keyvelsens"] = p[c]
		c = c + 1
		op["opamp"] = output_level_to_amp(p[c])
		c = c + 1
		if(p[c] == 1): # fixed
			op["fixedhz"] = coarse_fine_fixed_hz(p[c+1], p[c+2])
		else:
			op["ratio"] = coarse_fine_ratio(p[c+1], p[c+2])
		c = c + 3
		op["detunehz"] = p[c] - 7
		c = c + 1
		ops.append(op)
	ops.reverse() # start from op 1
	patch["ops"] = ops
	patch["pitcheg"] = [x for x in p[c:c+8]]
	c = c + 8
	patch["algo"] = p[c]
	c = c + 1
	patch["feedback"] = p[c]
	c = c + 1
	patch["oscsync"] = p[c]
	c = c + 1
	patch["lfospeed"] = p[c]
	c = c + 1
	patch["lfodelay"] = p[c]
	c = c + 1
	patch["lfopitchmoddepth"] = p[c]
	c = c + 1
	patch["lfoampmoddepth"] = p[c]
	c = c + 1
	patch["lfosync"] = p[c]
	c = c + 1
	patch["lfowaveform"] = lfo_wave(p[c])
	c = c + 1
	patch["pitchmodsens"] = p[c]
	c = c + 1
	patch["transpose"] = p[c]
	c = c + 1
	patch["name"] = p[c:c+10]
	c = c + 10
	return patch



