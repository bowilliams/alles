# fm.py

# Get dx7 from https://github.com/bwhitman/learnfm
import amy, dx7
import numpy as np
import time


# Convert DX7 patches to AMY commands


# Use learnfm's dx7 to render a dx7 note from MSFA
def dx7_render(patch_number, midinote, velocity, samples, keyup_sample):
	s = dx7.render(patch_number, midinote, velocity, samples, keyup_sample)
	return np.array(s)/32767.0

def setup_patch(p):
	# Take a patch and output AMY commands to set up the patch. Send amy.send(vel=0,osc=6,note=50) after
	pitchenv = p["bp_pitch"]
	# Set up each operator
	for i,op in enumerate(p["ops"]):
		freq_ratio = -1
		freq = -1
		# Set the ratio or the fixed freq
		if(op.get("fixedhz",None) is not None):
			freq = op["fixedhz"]
		else:
			freq_ratio = op["ratio"]
		amp = op["opamp"]/1.0
		# Set the operator-- freq, breakpoints for amp, breakpoints for pitch
		print("osc %d (op %d) freq %f ratio %f env %s amp %f" % (i, np.abs(i-6), freq, freq_ratio, op["bp_opamp"], amp))
		amy.send(osc=i, freq=freq, freq_ratio=freq_ratio,bp0_target=amy.TARGET_AMP+amy.TARGET_LINEAR,bp0=op["bp_opamp"], bp1=pitchenv, bp1_target=amy.TARGET_FREQ+amy.TARGET_LINEAR, amp=amp)

	# Set up the main carrier note
	feedback = p["feedback"]/14.0
	print("osc 6 (main)  algo %d feedback %f env %s" % ( p["algo"], feedback, pitchenv))
	amy.send(osc=6, wave=amy.ALGO, algorithm=p["algo"], feedback=feedback, algo_source="0,1,2,3,4,5", bp1=pitchenv, bp1_target=amy.TARGET_FREQ+amy.TARGET_LINEAR)

def plot(us, them):
	import matplotlib.pyplot as plt
	fig, (s0,s1) = plt.subplots(2,1)
	s0.specgram(us_samples, NFFT=512, Fs=amy.SAMPLE_RATE)
	s1.specgram(them_samples, NFFT=512, Fs=amy.SAMPLE_RATE)
	fig.show()


# Play our version vs the MSFA version to A/B test
def play_patch(patch_number, midinote=50, length_s = 2, keyup_s = 1):
	dx7_patch = dx7.unpack(patch_number)
	p = decode_patch(dx7_patch)
	print(str(p["name"]))
	setup_patch(p,midinote)

	amy.note_on(osc=6,vel=4)
	us_samples0 = amy.render(keyup_s)
	amy.note_off(osc=6)
	us_samples1 = amy.render(length_s - keyup_s)
	us_samples = np.hstack((us_samples0, us_samples1))

	them_samples = dx7_render(patch_number, midinote, 90, int(length_s*amy.SAMPLE_RATE),int(keyup_s*amy.SAMPLE_RATE))

	# Uncomment this to show a spectra
	#plot(us_samples, them_samples)

	print("AMY:")
	amy.play(us_samples)
	time.sleep(length_s)

	# A/B against MSFA 
	time.sleep(0.25)
	print("MSFA:")
	amy.play(them_samples)
	time.sleep(length_s)
	return p

def get_patch(patch_number):
	# returns a patch (as in patches.h) from 
    # unpacked.bin generated by dx7db, see https://github.com/bwhitman/learnfm
    f = bytes(open("unpacked.bin", mode="rb").read())
    patch_data = f[patch_number*156:patch_number*156+156]
    #name = ''.join([i if (ord(i) < 128 and ord(i) > 31) else ' ' for i in str(patch_data[145:155])])
    return patch_data

# Given a patch byte stream, return a json object that describes it
def decode_patch(p):

	def eg_to_bp(egrate, eglevel):
		# This is likely incorrect, but an ok start
		def rate_to_ms(rate):
			return (99-rate)*2.5 # 250ms is rate=0, 0ms is rate=99
		# http://www.audiocentralmagazine.com/wp-content/uploads/2012/04/dx7-envelope.png
		# or https://yamahasynth.com/images/RefaceSynthBasics/EG_RatesLevels.png
		# rate seems to be "speed", so higher rate == less time
		# NO idea what the time units are, so going to have to fudge this a bit
		# level is probably exp, but so is our ADSR? 
		bp = ""
		for i in range(4):
			ms = rate_to_ms(egrate[i])
			l = eglevel[i] / 99.0
			# Don't throw in the 0,0 type egs
			if(ms==0 and i>0):
				pass
			else:
				bp = bp + "%d,%f," % (ms,l)
		return bp[:-1]


	def output_level_to_amp(byte):
		# Sure could be a exp curve but seems a bit custom
		# https://i.stack.imgur.com/1FQqR.jpg
		if(byte<20): return 0
		if(byte<40): return 0.1/14
		if(byte<50): return 0.25/14
		if(byte<60): return 0.5/14
		if(byte<70): return 1.2/14
		if(byte<80): return 2.75/14
		if(byte<85): return 4./14
		if(byte<90): return 6./14
		if(byte<88): return 6.05/14
		if(byte<89): return 6.1/14
		if(byte<90): return 6.2/14
		if(byte<91): return 6.5/14
		if(byte<92): return 7./14
		if(byte<93): return 8./14
		if(byte<94): return 9./14
		if(byte<95): return 9.5/14
		if(byte<96): return 10./14
		if(byte<97): return 11./14
		if(byte<98): return 12.5/14
		if(byte<99): return 13./14
		return 1.0

	def lfo_wave(byte):
		if(byte == 0): return "triangle"
		if(byte == 1): return "ramp_down"
		if(byte == 2): return "ramp_up"
		if(byte == 3): return "pulse"
		if(byte == 4): return "sine"
		if(byte == 5): return "samplehold"
		return "unknown"

	def curve(byte):
		if(byte==0): return "-lin"
		if(byte==1): return "-exp"
		if(byte==2): return "+exp"
		if(byte==3): return "+lin"
		return "unknown"

	def coarse_fine_fixed_hz(coarse, fine):
		# so many are > 3 (7500 out of 38K.) msfa cuts it like this, not sure whats' up here. maybe the knob loops over? 
		coarse = coarse & 3 
		if(coarse==0):
			return 1 + ((fine / 10.0) )
		if(coarse==1):
			return 10 + (fine  )
		if(coarse==2):
			return 100 + ((fine * 10) )
		if(coarse==3):
			return 1000 + ((fine * 100.0) )
		print("fixed coarse > 3, is %d" % (coarse))
		return 0

	def coarse_fine_ratio(coarse,fine):
		if(coarse==0):
			return 0.5 + ((fine/200.0) - 0.5)
		coarse = coarse & 31 # see above
		return coarse + (fine/100.0)
		

	patch = {}
	ops = []
	# Starts at op 6
	c = 0
	for i in range(6):
		op = {}
		op["rate"] = [x for x in p[c:c+4]]
		op["level"] =  [x for x in p[c+4:c+8]]
		op["bp_opamp"] = eg_to_bp([x for x in p[c:c+4]], [x for x in p[c+4:c+8]])
		c = c + 8
		op["brkpt"] = p[c]
		c = c + 1
		op["leftrightcurves"] = [x for x in p[c:c+4]]
		c = c + 4
		op["kbdratescaling"] = p[c]
		c = c + 1
		op["ampmodsens"] = p[c]
		c = c + 1
		op["keyvelsens"] = p[c]
		c = c + 1
		op["opamp"] = output_level_to_amp(p[c])
		c = c + 1
		if(p[c] == 1): # fixed
			op["fixedhz"] = coarse_fine_fixed_hz(p[c+1], p[c+2])
		else:
			op["ratio"] = coarse_fine_ratio(p[c+1], p[c+2])
		op["coarse"] = p[c+1]
		op["fine"] = p[c+2]
		c = c + 3
		op["detunehz"] = p[c] - 7
		c = c + 1
		ops.append(op)
	ops.reverse() # start from op 1
	patch["ops"] = ops
	patch["bp_pitch"] = eg_to_bp([x for x in p[c:c+4]], [x for x in p[c+4:c+8]])
	c = c + 8
	patch["algo"] = p[c]
	c = c + 1
	patch["feedback"] = p[c]
	c = c + 1
	patch["oscsync"] = p[c]
	c = c + 1
	patch["lfospeed"] = p[c]
	c = c + 1
	patch["lfodelay"] = p[c]
	c = c + 1
	patch["lfopitchmoddepth"] = p[c]
	c = c + 1
	patch["lfoampmoddepth"] = p[c]
	c = c + 1
	patch["lfosync"] = p[c]
	c = c + 1
	patch["lfowaveform"] = lfo_wave(p[c])
	c = c + 1
	patch["pitchmodsens"] = p[c]
	c = c + 1
	patch["transpose"] = p[c]
	c = c + 1
	patch["name"] =  ''.join(chr(i) for i in p[c:c+10])
	c = c + 10
	return patch



