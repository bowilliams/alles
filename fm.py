# fm.py

# Get dx7 from https://github.com/bwhitman/learnfm
import amy, dx7
import numpy as np
import time


# Convert DX7 patches to AMY commands


# Use learnfm's dx7 to render a dx7 note from MSFA
def dx7_render(patch_number, midinote, velocity, samples, keyup_sample):
	s = dx7.render(patch_number, midinote, velocity, samples, keyup_sample)
	return np.array(s)/32767.0

def setup_patch(p):
	# Take a FM patch and output AMY commands to set up the patch. Send amy.send(vel=0,osc=6,note=50) after
	
	# Problem here, pitch values are such that 0 = -n octave, 99 = + n octave 
	# pitch level = 50 means no change (or 1 for us)
	# can our breakpoints handle negative numbers? 
	pitchenv = p["bp_pitch"]

	# Set up each operator
	for i,op in enumerate(p["ops"]):
		freq_ratio = -1
		freq = -1
		# Set the ratio or the fixed freq
		if(op.get("fixedhz",None) is not None):
			freq = op["fixedhz"]
		else:
			freq_ratio = op["ratio"]
		amp = op["opamp"] / 2.0
		# Set the operator-- freq, breakpoints for amp, breakpoints for pitch
		# Not yet implemented:
		#	detune -- have to pass +/- Hz somehow, even for ratio 
		#	LFOs
		#   keyboard scaling
		#   transpose
		#   osc sync
		print("osc %d (op %d) freq %f ratio %f beta-bp %s pitch-bp %s beta %f" % (i, (i-6)*-1, freq, freq_ratio, op["bp_opamp"], pitchenv, amp))
		amy.send(osc=i, freq=freq, freq_ratio=freq_ratio,bp0_target=amy.TARGET_AMP+amy.TARGET_LINEAR,bp0=op["bp_opamp"], bp1=pitchenv, bp1_target=amy.TARGET_FREQ+amy.TARGET_LINEAR, amp=amp)

	# Set up the main carrier note
	feedback = p["feedback"]/14.0
	print("osc 6 (main)  algo %d feedback %f pitchenv %s" % ( p["algo"], feedback, pitchenv))
	amy.send(osc=6, wave=amy.ALGO, algorithm=p["algo"], feedback=feedback, algo_source="0,1,2,3,4,5", bp1=pitchenv, bp1_target=amy.TARGET_FREQ+amy.TARGET_LINEAR)

def plot(us, them):
	import matplotlib.pyplot as plt
	fig, (s0,s1) = plt.subplots(2,1)
	s0.specgram(us_samples, NFFT=512, Fs=amy.SAMPLE_RATE)
	s1.specgram(them_samples, NFFT=512, Fs=amy.SAMPLE_RATE)
	fig.show()


# Play our version vs the MSFA version to A/B test
def play_patch(patch_number, midinote=50, length_s = 2, keyup_s = 1):
	dx7_patch = dx7.unpack(patch_number)
	p = decode_patch(dx7_patch)
	print(str(p["name"]))
	setup_patch(p,midinote)

	amy.note_on(osc=6,vel=4)
	us_samples0 = amy.render(keyup_s)
	amy.note_off(osc=6)
	us_samples1 = amy.render(length_s - keyup_s)
	us_samples = np.hstack((us_samples0, us_samples1))

	them_samples = dx7_render(patch_number, midinote, 90, int(length_s*amy.SAMPLE_RATE),int(keyup_s*amy.SAMPLE_RATE))

	# Uncomment this to show a spectra
	#plot(us_samples, them_samples)

	print("AMY:")
	amy.play(us_samples)
	time.sleep(length_s)

	# A/B against MSFA 
	time.sleep(0.25)
	print("MSFA:")
	amy.play(them_samples)
	time.sleep(length_s)
	return p

def get_patch(patch_number):
	# returns a patch (as in patches.h) from 
    # unpacked.bin generated by dx7db, see https://github.com/bwhitman/learnfm
    f = bytes(open("unpacked.bin", mode="rb").read())
    patch_data = f[patch_number*156:patch_number*156+156]
    #name = ''.join([i if (ord(i) < 128 and ord(i) > 31) else ' ' for i in str(patch_data[145:155])])
    return patch_data

# Given a patch byte stream, return a json object that describes it
def decode_patch(p):
	def eg_to_bp(egrate, eglevel):
		# This is likely incorrect, but an ok start
		def rate_to_ms(rate):
			"""
				"It may take over half a minute to reach level 1, depending on the setting of RATE 1 (R1)."
			"""
			# From MSFA. This is likely in samples to advance per sample?
			ratetab = [
				1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12,
				12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 23, 24,
				25, 26, 27, 28, 30, 31, 33, 34, 36, 37, 38, 39, 41, 42, 44, 46, 47,
				49, 51, 53, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 79, 82,
				85, 88, 91, 94, 98, 102, 106, 110, 115, 120, 125, 130, 135, 141, 147,
				153, 159, 165, 171, 178, 185, 193, 202, 211, 232, 243, 254, 255]
			# This must be exp scaled so that 0 is 30 seconds, 1 is 10 seconds, 2 is 1 second, etc .. 
			# I don't know what i'm doing here, need help with this bit 
			return 90000. / (ratetab[rate]*64.0)

		# http://www.audiocentralmagazine.com/wp-content/uploads/2012/04/dx7-envelope.png
		# or https://yamahasynth.com/images/RefaceSynthBasics/EG_RatesLevels.png
		# rate seems to be "speed", so higher rate == less time
		# level is probably exp, but so is our ADSR? 
		print ("Input rate %s level %s" %(egrate, eglevel))
		bp = ""
		total_ms = 0
		for i in range(4):
			ms = rate_to_ms(egrate[i])
			l = eglevel[i] / 99.0
			if(i!=3):
				total_ms = total_ms + ms
				bp = bp + "%d,%f," % (total_ms,l)
			else:
				# Release ms counter happens separately, so don't add
				bp = bp + "%d,%f" % (ms, l)
		print ("return %s" % (bp[:-1]))
		return bp[:-1]


	def output_level_to_amp(byte):
		# Sure could be a exp curve but seems a bit custom
		# https://i.stack.imgur.com/1FQqR.jpg
		"""
		From Dan:
			When doing phase modulation in LUTs, there’s the factor of lut_size (the difference between 
			phase and scaled_phase).  So 0.2 in the “phase” domain becomes 51.2 if we scale it up for a 256 pt LUT
		"""
		if(byte<20): return 0
		if(byte<40): return 0.1/14
		if(byte<50): return 0.25/14
		if(byte<60): return 0.5/14
		if(byte<70): return 1.2/14
		if(byte<80): return 2.75/14
		if(byte<85): return 4./14
		if(byte<90): return 6./14
		if(byte<88): return 6.05/14
		if(byte<89): return 6.1/14
		if(byte<90): return 6.2/14
		if(byte<91): return 6.5/14
		if(byte<92): return 7./14
		if(byte<93): return 8./14
		if(byte<94): return 9./14
		if(byte<95): return 9.5/14
		if(byte<96): return 10./14
		if(byte<97): return 11./14
		if(byte<98): return 12.5/14
		if(byte<99): return 13./14
		return 1.0

	def lfo_wave(byte):
		if(byte == 0): return "triangle"
		if(byte == 1): return "ramp_down"
		if(byte == 2): return "ramp_up"
		if(byte == 3): return "pulse"
		if(byte == 4): return "sine"
		if(byte == 5): return "samplehold" # noise?
		return "unknown"

	def curve(byte):
		if(byte==0): return "-lin"
		if(byte==1): return "-exp"
		if(byte==2): return "+exp"
		if(byte==3): return "+lin"
		return "unknown"

	def coarse_fine_fixed_hz(coarse, fine):
		# so many are > 3 (7500 out of 38K.) msfa cuts it like this, not sure whats' up here. maybe the knob loops over? 
		coarse = coarse & 3 
		if(coarse==0):
			return 1 + ((fine / 10.0) )
		if(coarse==1):
			return 10 + (fine  )
		if(coarse==2):
			return 100 + ((fine * 10) )
		if(coarse==3):
			return 1000 + ((fine * 100.0) )
		print("fixed coarse > 3, is %d" % (coarse))
		return 0

	def coarse_fine_ratio(coarse,fine):
		if(coarse==0):
			return 0.5 + ((fine/200.0) - 0.5)
		coarse = coarse & 31 # see above
		return coarse + (fine/100.0)
		

	patch = {}
	ops = []
	# Starts at op 6
	c = 0
	for i in range(6):
		op = {}
		op["rate"] = [x for x in p[c:c+4]]
		op["level"] =  [x for x in p[c+4:c+8]]
		op["bp_opamp"] = eg_to_bp([x for x in p[c:c+4]], [x for x in p[c+4:c+8]])
		c = c + 8
		op["brkpt"] = p[c]
		c = c + 1
		op["leftrightcurves"] = [x for x in p[c:c+4]]
		c = c + 4
		op["kbdratescaling"] = p[c]
		c = c + 1
		op["ampmodsens"] = p[c]
		c = c + 1
		op["keyvelsens"] = p[c]
		c = c + 1
		op["opamp"] = output_level_to_amp(p[c])
		c = c + 1
		if(p[c] == 1): # fixed
			op["fixedhz"] = coarse_fine_fixed_hz(p[c+1], p[c+2])
		else:
			op["ratio"] = coarse_fine_ratio(p[c+1], p[c+2])
		op["coarse"] = p[c+1]
		op["fine"] = p[c+2]
		c = c + 3
		op["detunehz"] = p[c] - 7
		c = c + 1
		ops.append(op)

	patch["ops"] = ops

	patch["bp_pitch"] = eg_to_bp([x for x in p[c:c+4]], [x for x in p[c+4:c+8]])
	c = c + 8
	patch["algo"] = p[c]
	c = c + 1
	patch["feedback"] = p[c]
	c = c + 1
	patch["oscsync"] = p[c]
	c = c + 1
	patch["lfospeed"] = p[c]
	c = c + 1
	patch["lfodelay"] = p[c]
	c = c + 1
	patch["lfopitchmoddepth"] = p[c]
	c = c + 1
	patch["lfoampmoddepth"] = p[c]
	c = c + 1
	patch["lfosync"] = p[c]
	c = c + 1
	patch["lfowaveform"] = lfo_wave(p[c])
	c = c + 1
	patch["pitchmodsens"] = p[c]
	c = c + 1
	patch["transpose"] = p[c]
	c = c + 1
	patch["name"] =  ''.join(chr(i) for i in p[c:c+10])
	c = c + 10
	return patch



