# fm.py
# Some code to try to convert dx7 patches into AMY commands
# Use the dx7 module if you want to A/B test AMY's FM mode against a dx7 emulation.
# AMY is not a dx7 emulator, so it's not going to be perfect or even close, especially for some of the weirder modes of the dx7
# but fun to play with!
# Get the dx7 module from https://github.com/bwhitman/learnfm
import alles, dx7
import numpy as np
import time

from dataclasses import dataclass
from typing import List

""" Howto

# git clone https://github.com/bwhitman/alles.git
# git clone https://github.com/bwhitman/learnfm.git
# cd learnfm/dx7core
# [edit line 129 of learnfm/dx7core/pydx7.cc to point to the folder you cloned learnfm into for compact.bin]
# make
# python setup.py install

    [ If you get an error and are on an older macOS, try:
    ARCHFLAGS="-arch x86_64" python setup.py install  ]

# cd ../../alles/main

    [ install homebrew if you haven't yet:
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" ] 

# brew install libsoundio
# make
# ./alles -i 127.0.0.1 [you should hear the alles bleep, if not, change your speaker settings]
# [open a new terminal]
# python
>>> import fm
>>> fm.alles.connect(local_ip='127.0.0.1')
>>> fm.play_patch(234) # any number up to 31000
# You should hear Alles play it, then Raph L play it
# Or, you can grab a patch and modify it
>>> piano = fm.DX7Patch.from_patch_number(29978)
>>> piano.algo = 2 # change DX7 algorithm from 5 to 2 
>>> fm.play_patch(piano) # plays modified patch on both types
"""

@dataclass
class DX7Operator:
    """Per-operator parameters for DX7 patches."""
    opnum: int = 0
    rates: List[int] = None  # 4
    levels: List[int] = None # 4
    breakpoint: int = 0
    bp_depths: List[int] = None # 2
    bp_curves: List[int] = None # 2
    kbdratescaling: int = 0
    ampmodsens: int = 0
    keyvelsens: int = 0
    ratiotuning: bool = False
    freq_coarse: int = 0
    freq_fine: int = 0
    freq_detune: int = 0

@dataclass
class DX7Patch:
    """Encapsulates information in a DX7 Patch."""
    ops: List[DX7Operator] = None
    pitch_rates: List[int] = None # 4
    pitch_levels: List[int] = None # 4
    algo: int = 0  # 1-32
    feedback: int = 0
    oscsync: int = 0
    lfospeed: int = 0
    lfodelay: int = 0
    lfopitchmoddepth: int = 0
    lfoampmoddepth: int = 0
    lfosync: int = 0
    lfowaveform: int = 0
    pitchmodsens: int = 0
    transpose: int = 0
    name: str = ""

    @staticmethod
    def from_patch_number(patch_number):
        # returns a patch (as in patches.h) from 
        # unpacked.bin generated by dx7db, see https://github.com/bwhitman/learnfm
        f = bytes(open("unpacked.bin", mode="rb").read())
        patch_data = f[patch_number*156:patch_number*156+156]
        #name = ''.join([i if (ord(i) < 128 and ord(i) > 31) else ' ' for i in str(patch_data[145:155])])
        return DX7Patch.from_bytestream(bytearray(patch_data))

    @staticmethod
    def from_bytestream(bytestream):
        """Simply reformat the bytestream into parameters."""
        result = DX7Patch()

        bytestream = bytes(bytestream)
        byteno = 0

        def nextbyte(count=1):
            nonlocal byteno
            if count > 1:
                # Return a list.
                return [nextbyte() for _ in range(count)]
            b = bytestream[byteno]
            byteno += 1
            # Return a bare byte.
            return b

        ops = []
        # Starts at op 6
        for i in range(6, 0, -1):
            op = DX7Operator(opnum=i)
            op.rates = nextbyte(4)
            op.levels = nextbyte(4)
            op.breakpoint = nextbyte()
            op.bp_depths = nextbyte(2)
            op.bp_curves = nextbyte(2)
            op.kbdratescaling = nextbyte()
            op.ampmodsens = nextbyte()
            op.keyvelsens = nextbyte()
            op.opamp = nextbyte()
            op.ratiotuning = False if nextbyte() == 1 else True
            op.coarse = nextbyte()
            op.fine = nextbyte()
            op.detune = nextbyte()
            ops.append(op)
        result.ops = ops
        result.pitch_rates = nextbyte(4)
        result.pitch_levels = nextbyte(4)
        result.algo = 1 + nextbyte()
        result.feedback = nextbyte()
        result.oscsync = nextbyte()
        result.lfospeed = nextbyte()
        result.lfodelay = nextbyte()
        result.lfopitchmoddepth = nextbyte()
        result.lfoampmoddepth = nextbyte()
        result.lfosync = nextbyte()
        result.lfowaveform = nextbyte()
        result.pitchmodsens = nextbyte()
        result.transpose = nextbyte()
        result.name =  ''.join(chr(i) for i in nextbyte(10))
        return result

    def get_bytestream(self):
        """Convert a decoded patch dict back to a bytestream."""
        bytestream = []
        for op in self.ops:
            # Assume ordering is right in ops list.
            bytestream.extend(op.rates)
            bytestream.extend(op.levels)
            bytestream.append(op.breakpoint)
            bytestream.extend(op.bp_depths)
            bytestream.extend(op.bp_curves)
            bytestream.append(op.kbdratescaling)
            bytestream.append(op.ampmodsens)
            bytestream.append(op.keyvelsens)
            bytestream.append(op.opamp)
            bytestream.append(0 if op.ratiotuning else 1)
            bytestream.append(op.coarse)
            bytestream.append(op.fine)
            bytestream.append(op.detune)
        bytestream.extend(self.pitch_rates)
        bytestream.extend(self.pitch_levels)
        bytestream.append(self.algo - 1)
        bytestream.append(self.feedback)
        bytestream.append(self.oscsync)
        bytestream.append(self.lfospeed)
        bytestream.append(self.lfodelay)
        bytestream.append(self.lfopitchmoddepth)
        bytestream.append(self.lfoampmoddepth)
        bytestream.append(self.lfosync)
        bytestream.append(self.lfowaveform)
        bytestream.append(self.pitchmodsens)
        bytestream.append(self.transpose)
        bytestream.extend(ord(c) for c in self.name)
        return bytes(bytestream)

@dataclass
class AMYOscillator:
    op_num: int = 0
    amp_levels: List[float] = None
    amp_times: List[float] = None
    op_amp: float = 0
    ampmodsens: float = 0
    frequency: float = 0
    freq_is_ratio: bool = False

    @staticmethod
    def from_dx7_op(op):
        result = AMYOscillator()
        result.op_num = op.opnum
        result.amp_levels, result.amp_times = eg_to_bp(op.rates, op.levels)
        result.op_amp = 2 * dx7level_to_linear(op.opamp)
        if op.ratiotuning:
            result.frequency = coarse_fine_ratio(op.coarse, op.fine, op.detune)
            result.freq_is_ratio = True
        else:
            result.frequency = coarse_fine_fixed_hz(op.coarse, op.fine, op.detune)
            result.freq_is_ratio = False
        result.ampmodsens = float(op.ampmodsens)  # Don't know scaling, just 0/nonzero.
        return result
    
@dataclass
class AMYPatch:
    oscs: List[AMYOscillator] = None
    pitch_levels: List[float] = None
    pitch_times: List[float] = None
    algo: int = 0
    feedback: float = 0
    lfo_freq: float = 0
    lfo_delay: float = 0
    lfo_pitchmoddepth: float = 0
    lfo_ampmoddepth: float = 0
    lfo_waveform: int = 0
    name: str = ""
    exp_type: float = alles.TARGET_DX7_EXPONENTIAL
    amp_lfo_amp: float = 0 
    pitch_lfo_amp: float = 0

    @staticmethod
    def from_dx7(dx7_patch):
        result = AMYPatch()
        result.oscs = []
        for op in dx7_patch.ops:
            result.oscs.append(AMYOscillator.from_dx7_op(op))
        result.pitch_levels, result.pitch_times = eg_to_bp_pitch(
            dx7_patch.pitch_rates, dx7_patch.pitch_levels)
        result.algo = dx7_patch.algo
        result.feedback = 0.00125 * (2 ** dx7_patch.feedback)
        result.lfo_freq = lfo_speed_to_hz(dx7_patch.lfospeed)
        result.lfo_delay = dx7_patch.lfodelay
        result.lfo_pitchmoddepth = dx7_patch.lfopitchmoddepth
        result.lfo_ampmoddepth = dx7_patch.lfoampmoddepth
        result.lfo_waveform = lfo_wave(dx7_patch.lfowaveform)
        result.amp_lfo_amp = dx7level_to_linear(result.lfo_ampmoddepth)
        result.pitch_lfo_amp = dx7level_to_linear(result.lfo_pitchmoddepth)

        result.name = dx7_patch.name
        return result
    
    def send_to_AMY(self):
        # Take a FM patch and output AMY commands to set up the patch.
        # Send alles.send(vel=0,osc=6,note=50) after
    
        alles.reset()
        pitch_levels, pitch_times = self.pitch_levels, self.pitch_times
        pitchbp = "%d,%f,%d,%f,%d,%f,%d,%f,%d,%f" % (
            pitch_times[0], pitch_levels[0], pitch_times[1], pitch_levels[1],
            pitch_times[2], pitch_levels[2], pitch_times[3], pitch_levels[3],
            pitch_times[4], pitch_levels[4])
        # Set up each operator.
        last_release_time = 0
        last_release_value = 0
        for i, osc in enumerate(self.oscs):
            amp_levels, amp_times = osc.amp_levels, osc.amp_times
            oscbp = "%d,%f,%d,%f,%d,%f,%d,%f,%d,%f" % (
                amp_times[0], amp_levels[0], amp_times[1], amp_levels[1],
                amp_times[2], amp_levels[2], amp_times[3], amp_levels[3],
                amp_times[4], amp_levels[4])
            oscbpfmt = "%d,%.3f/%d,%.3f/%d,%.3f/%d,%.3f/%d,%.3f" % (
                amp_times[0], amp_levels[0], amp_times[1], amp_levels[1],
                amp_times[2], amp_levels[2], amp_times[3], amp_levels[3],
                amp_times[4], amp_levels[4])
            if(amp_times[4] > last_release_time):
                last_release_time = amp_times[4]
                last_release_value = amp_levels[4]
            print("osc %d (op %d) freq %.1f ratio %d env %s amp %.3f amp_mod %d" % \
                  (i, osc.op_num, osc.frequency, osc.freq_is_ratio, oscbpfmt,
                   osc.op_amp, osc.ampmodsens))

            # Make them all in cosine phase, to be like DX7.  Important for slow oscs
            args = {"osc":i,
                    "bp0_target":alles.TARGET_AMP+self.exp_type,
                    "bp0":oscbp, "amp":osc.op_amp, "phase":0.25}
            if osc.freq_is_ratio:
                args["ratio"] = osc.frequency
            else:
                args["freq"] = osc.frequency
            if(osc.ampmodsens > 0):
                # TODO: we ignore intensity of amp mod sens, just on/off
                args.update({"mod_source": 7, "mod_target":alles.TARGET_AMP})
            args.update({"bp1": pitchbp,
                         "bp1_target": alles.TARGET_FREQ+self.exp_type})
            alles.send(**args)

        # Set up the amp LFO 
        print("osc 7 amp lfo wave %d freq %f amp %f" % (
            self.lfo_waveform, self.lfo_freq, self.amp_lfo_amp))
        alles.send(osc=7, wave=self.lfo_waveform, freq=self.lfo_freq,
                   amp=self.amp_lfo_amp)

        # and the pitch one
        print("osc 8 pitch lfo wave %d freq %f amp %f" % (
            self.lfo_waveform, self.lfo_freq, self.pitch_lfo_amp))
        alles.send(osc=8, wave=self.lfo_waveform, freq=self.lfo_freq,
                   amp=self.pitch_lfo_amp)

        print("not used: lfo delay %d " % self.lfo_delay)

        ampbp = "0,1,%d,%f" % (last_release_time, last_release_value)
        print("osc 6 (main)  algo %d feedback %f pitchenv %s ampenv %s" % (
            self.algo, self.feedback, pitchbp, ampbp))
        alles.send(osc=6, wave=alles.ALGO, algorithm=self.algo, feedback=self.feedback,
                   algo_source="0,1,2,3,4,5",
                   bp0=ampbp, bp0_target=alles.TARGET_AMP+alles.TARGET_TRUE_EXPONENTIAL,
                   bp1=pitchbp, bp1_target=alles.TARGET_FREQ+alles.TARGET_TRUE_EXPONENTIAL,
                   mod_target=alles.TARGET_FREQ, mod_source=8)

def dx7level_to_linear(dx7level):
    """Map the dx7 0..99 levels to linear amplitude."""
    return 2 ** ((dx7level - 99) / 8)

def linear_to_dx7level(linear):
    """Map a linear amplitude to the dx7 0..99 scale."""
    return np.log2(np.maximum(dx7level_to_linear(0), linear)) * 8 + 99
    
def calc_loglin_eg_breakpoints(rates, levels):
    """Convert the DX7 rates/levels into (time, target) pairs (for alles)"""
    # This is the part we precompute in fm.py to get breakpoints to send to alles.
    current_level = 0 # it seems, not levels[-1]
    cumulated_time = 0
    breakpoints = [(cumulated_time, current_level)]

    MIN_LEVEL = 34
    ATTACK_RANGE = 75

    def level_to_time(level, t_const):
        """Return the time at which a paradigmatic DX7 attack envelope will reach a level (0..99 range)"""
        # Return the t0 that solves level = MIN_LEVEL + ATTACK_RANGE * (1 - exp(-t0 / t_const))
        return -t_const * np.log((MIN_LEVEL + ATTACK_RANGE - np.maximum(MIN_LEVEL, level))/ATTACK_RANGE)

    for segment, (rate, target_level) in enumerate(zip(rates, levels)):
        release_segment = (segment == len(rates)-1)
        if target_level > current_level:   # Attack segment
            # The attack envelopes L(t) appear to be ~ 34 + 75 * (1 - exp(t / t_const)), starting from L = 34
            # i.e. they are rising exponentials (as in analog ADSR, but here in the log(amp) domain) 
            # with an asymptote at 109 (i.e., 10 higher than the highest possible amp).
            # The time constant depends on the R (rate) parameter, and is well fit by:
            t_const = 0.008 * (2 ** ((65 - rate)/6))
            # Total time for this segment is t1 - t0 where t0 and t1 solve
            # effective_start = 34 + 75 * (1 - np.exp(-t0 / t_const)) = 109 - 75 exp(-t0 / t_c)
            # target_level = 34 + 75 * (1 - np.exp(-t1 / t_const)) = 109 - 75 exp(-t1 / t_c)
            # so t1 - t0 = -t_c * [log((34 + 75 - target_level)/75) - log((34 + 75 - effective_start)/75)]
            effective_start_level = np.maximum(current_level, MIN_LEVEL)
            t0 = level_to_time(effective_start_level, t_const)
            segment_duration = level_to_time(target_level, t_const) - t0
            #print("eff_st=", effective_start_level, "t_c=", t_const, "t0=", t0, "dur=", segment_duration)
            # Now alles's task will be to recover t0 and t_const from (time, target) pairs
        else:
            # Decay segment.
            # "A falling segment takes 3.5 mins"
            # so delta = 99 in 210 seconds -> level_change_per_sec =  0.5
            # I think just offset everything by 0.5, avoids div0.          
            level_change_per_sec = -0.5 - 8 * (2 ** ((rate - 24) / 6))
            level_difference = target_level - current_level
            # Hack to cover for sustain = 0, release = 0 release segments which look like they should be zero long
            if release_segment and level_difference == 0:
                level_difference = -60  # e.g. from a decayed level of 80 to zero.
                #print("** Goosing release amp")
            segment_duration = level_difference / level_change_per_sec
            #print("lcps=", level_change_per_sec, "dur=", segment_duration)
        cumulated_time += segment_duration
        breakpoints.append((cumulated_time, dx7level_to_linear(target_level)))
        current_level = target_level
    return breakpoints

def EG_seg_time(L0, L1, R):
    """How long will it take to get from L0 to L1 at rate R (all 0..99)?"""
    # L is 8 steps per doubling
    # R is 6 steps per doubling of time, with 24 = 1 sec per doubling of amplitude
    doublings = np.abs((L0 & -2) - (L1 & -2)) / 8  # LSB of levels is ignored
    doublings_per_sec = 2 ** ((R - 24) / 6)
    return doublings / doublings_per_sec

def eg_to_bp(egrate, eglevel):
    breakpoints = calc_loglin_eg_breakpoints(egrate, eglevel)
    rates = []
    times = []
    for time, level in breakpoints:
        times.append(int(1000 * time))
        rates.append(level)
    # Fix release time to be relative to 0, not previous
    times[-1] -= times[-2]
    return rates, times

def eg_to_bp_orig(egrate, eglevel):
    # http://www.audiocentralmagazine.com/wp-content/uploads/2012/04/dx7-envelope.png
    # or https://yamahasynth.com/images/RefaceSynthBasics/EG_RatesLevels.png
    # rate seems to be "speed", so higher rate == less time
    # level is probably exp, but so is our ADSR? 
    #print ("Input rate %s level %s" %(egrate, eglevel))

    # We're adding a (0,0) at the start - this will become level 4
    times = [0,0,0,0,0]
    rates = [0,0,0,0,0]

    total_ms = 0
    last_L = eglevel[-1]
    for i in range(4):
        # Segment 0 (attack) is a special case, it's 4x faster (24 steps higher).
        ms = 1000 * EG_seg_time(last_L, eglevel[i], egrate[i] + 12*(i==0))
        last_L = eglevel[i]
        l = dx7level_to_linear(eglevel[i])
        if(i!=3):
            total_ms = total_ms + ms
            times[i+1] = total_ms
            rates[i+1] = l
        else:
            # Release ms counter happens separately, so don't add
            times[i+1] = 1000 * EG_seg_time(eglevel[0], eglevel[i], egrate[i])
            # Chop the release at ALLES_MAX_DRIFT 
            if(times[i+1] > alles.ALLES_MAX_DRIFT_MS):
                times[i+1] = alles.ALLES_MAX_DRIFT_MS
            rates[i+1] = l
    # per dx7 spec, level[0] == level[3]
    rates[0] = rates[4]
    return (rates, times)

def eg_to_bp_pitch(egrate, eglevel):
    rates, times = eg_to_bp_orig(egrate, eglevel)
    for i in range(len(rates)):
        rates[i] /= 0.014328
    return (rates, times)

def coarse_fine_fixed_hz(coarse, fine, detune=7):
    coarse = coarse & 3
    return 10 ** (coarse + (fine + ((detune - 7) / 8)) / 100 )
    
def coarse_fine_ratio(coarse, fine, detune=7):
    coarse = coarse & 31
    if(coarse == 0):
        coarse = 0.5
    return coarse * (1 + (fine + ((detune - 7) / 8)) / 100)

def lfo_speed_to_hz(byte):
    # Measured values from TX802, linear fit by eye
    if byte == 0:
        return 0.064
    if byte <= 64:
        return byte / 6.0
    if byte <= 85:
        return byte - 64.0 * 5.0/6.0
    # Byte > 85
    return 31.67 + (byte - 85.0) * 1.33

def lfo_wave(byte):
    if byte > 5:
        return None
    return [
        alles.TRIANGLE, alles.SAW_DOWN, alles.SAW_UP, 
        alles.PULSE, alles.SINE, alles.NOISE
    ][byte]


##### AB testing / debug stuff here

# Send a message to brian's tx802 and hear it from the live stream
# do it like
# import fm
# fm._token = "thing brian gives you"
# fm.tx802_patch(fm.get_patch(43)) # or whatever patch data you create
# fm.tx802_note_on(50)
# fm.tx802_note_off(50)
# if it gets stuck, just send tx802_patch again, it'll stop the synth

_token = ""
def send_to_tx802(message):
    import uuid, urllib, json
    room_id="!ETtPRVnMRSWWCmsHQJ:duraflame.rosaline.org"
    event_type="m.room.message"
    data={"msgtype":"m.text","body":message}
    url="https://duraflame.rosaline.org/_matrix/client/v3/rooms/%s/send/%s/%s" % (room_id, event_type, str(uuid.uuid4()))
    r=urllib.request.Request(url, data=bytes(json.dumps(data).encode('utf-8')), method='PUT')
    r.add_header('Authorization',"Bearer %s" %(_token))
    urllib.request.urlopen(r)

def tx802_note_on(note_number):
    import base64
    send_to_tx802("noteon " + str(note_number) + " " + base64.b64encode(b"nothing").decode('ascii'))

def tx802_note_off(note_number):
    import base64
    send_to_tx802("noteoff " + str(note_number) + " " + base64.b64encode(b"nothing").decode('ascii'))

def tx802_patch(patch_data):
    import base64
    # fm.get_patch() now returns 156 bytes, not 155, because of the live operator on/off byte i guess... strip it
    if(len(patch_data)==156):
        patch_data = patch_data[:-1]
    send_to_tx802("patch " + str(0) + " " + base64.b64encode(patch_data).decode('ascii'))


# Play a numpy array on a mac without having to use an external library
def play_np_array(np_array, samplerate=alles.SAMPLE_RATE):
    import wave, tempfile , os, struct
    tf = tempfile.NamedTemporaryFile()
    obj = wave.open(tf,'wb')
    obj.setnchannels(1) # mono
    obj.setsampwidth(2)
    obj.setframerate(samplerate)
    for i in range(np_array.shape[0]):
        value = int(np_array[i] * 32767.0)
        data = struct.pack('<h', value)
        obj.writeframesraw( data )
    obj.close()
    os.system("afplay " + tf.name)
    tf.close()


# Use learnfm's dx7 to render a dx7 note from MSFA
def dx7_render(patch, midinote, velocity, samples, keyup_sample):
    if(type(patch)==int):
        s = dx7.render(patch, midinote, velocity, samples, keyup_sample)
    else:
        s = dx7.render_patchdata(patch, midinote, velocity, samples, keyup_sample)
    return np.array(s)/32767.0


# Play our version vs the MSFA version to A/B test
def play_patch(patch, midinote=50, length_s = 4, keyup_s = 2, vel=2):
    # You can pass in a patch # (0-31000 or so) or a 156 byte patch, which you can modify
    if type(patch) == int:
        dx7_patch = DX7Patch.from_patch_number(patch)
    elif type(patch) == bytes:
        dx7_patch = DX7Patch.from_bytestream(patch)
    else:
        dx7_patch = patch
        
    print(dx7_patch.name)
    p = AMYPatch.from_dx7(dx7_patch)

    print("AMY:")
    p.send_to_AMY()

    alles.send(osc=6,vel=vel,note=midinote,timestamp=alles.millis())
    alles.send(osc=6,vel=0,timestamp=alles.millis() + (length_s-keyup_s)*1000)
    # Catch up to latency
    time.sleep(length_s + alles.ALLES_LATENCY_MS/1000)
    alles.reset()
    time.sleep(0.5)
    # Render Raph
    print("MSFA:")
    them_samples = dx7_render(dx7_patch.get_bytestream(),
                              midinote, 90,
                              int(length_s*alles.SAMPLE_RATE),
                              int(keyup_s*alles.SAMPLE_RATE))
    play_np_array(them_samples)



#### Header file stuff below

def generate_fm_header(patch_nums=None):
    import sys
    # given a list of patch numbers, output a fm.h
    all_patches = []
    ids = []
    if(patch_nums is None):
        sys.path.append('../learnfm')
        import dx7db
        # generate the list based on the dx7 default ROMs, which have 1024 patches
        all_default_patches = dx7db.parse_all(do_dedup=False)
        for i,patch in enumerate(all_default_patches):
            ids.append(i)
            p = AMYPatch.from_dx7(DX7Patch.from_bytestream(patch))
            all_patches.append(p)
    else:
        for patch_num in patch_nums:
            ids.append(patch_num)
            p = AMYPatch.from_dx7(DX7Patch.from_patch_number(patch_num))
            all_patches.append(p)
    pitch_fix = 0
    amp_fix = 0
    out = open("main/amy/fm.h", "w")
    out.write("// Automatically generated by fm.generate_fm_header()\n#ifndef __FM_H\n#define __FM_H\n#define ALGO_PATCHES %d\n" % (len(all_patches)))
    out.write("const algorithms_parameters_t fm_patches[ALGO_PATCHES] = {\n")
    for idx, p in enumerate(all_patches):
        for x in range(5):
            if(p.pitch_times[x] > 65535):
                print("patch %d pitch times %d is %d" % ( idx, x, p.pitch_times[x]))
                p.pitch_times[x] = 65535
                pitch_fix += 1
        out.write("\t{ %d, %f, {%f, %f, %f, %f, %f}, {%d, %d, %d, %d, %d}, %f, %d, %f, %f, {\n" % (
            p.algo, p.feedback,
            p.pitch_levels[0], p.pitch_levels[1], p.pitch_levels[2], p.pitch_levels[3], p.pitch_levels[4], 
            p.pitch_times[0], p.pitch_times[1], p.pitch_times[2], p.pitch_times[3], p.pitch_times[4],
            p.lfo_freq, p.lfo_waveform, p.amp_lfo_amp, p.pitch_lfo_amp))
        for i, osc in enumerate(p.oscs):
            if osc.ampmodsens > 0:
                lfo_target = alles.TARGET_AMP
            else:
                lfo_target = 0
            if osc.freq_is_ratio:
                ratio = osc.frequency
                frequency = -1
            else:
                ratio = -1
                frequency = osc.frequency
            for x in range(5):
                if(osc.amp_times[x] > 65535):
                    print("patch %d osc %d amp times %d is %d" %(idx, i , x, osc.amp_times[x]))
                    osc.amp_times[x] = 65535
                    amp_fix += 1

            out.write("\t\t\t{%f, %f, %f, {%f, %f, %f, %f, %f}, {%d, %d, %d, %d, %d}, %d}, /* op %d */\n" % (
                frequency, ratio, osc.op_amp,
                osc.amp_levels[0], osc.amp_levels[1], osc.amp_levels[2], osc.amp_levels[3], osc.amp_levels[4], 
                osc.amp_times[0], osc.amp_times[1], osc.amp_times[2], osc.amp_times[3], osc.amp_times[4],
                lfo_target, 6 - i))
        out.write("\t\t},\n\t}, /* %s (%d) */ \n" % (p.name, ids[idx]))
    out.write("};\n#endif // __FM_H\n")
    out.close()
    print("pitch fixed %d amp fixed %d" % (pitch_fix, amp_fix))



