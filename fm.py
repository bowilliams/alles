# fm.py
import amy, dx7
import numpy as np
import time
#import matplotlib.pyplot as plt

# Converting DX7 patches to AMY commands

#amy.start()


def dx7_render(patch_number, midinote, velocity, samples, keyup_sample):
	s = dx7.render(patch_number, midinote, velocity, samples, keyup_sample)
	return np.array(s)/32767.0

def setup_patch(p, midinote):
	for i,op in enumerate(p["ops"]):
		freq_ratio = -1
		freq = -1
		if(op.get("fixedhz",None) is not None):
			freq = op["fixedhz"]
		else:
			freq_ratio = op["ratio"]
		amy.send(osc=i, freq=freq, freq_ratio=freq_ratio,adsr_target=amy.TARGET_AMP,envelope=op["envelope"], amp=op["opamp"]/4.0)
	amy.send(osc=6, note=midinote, wave=amy.ALGO, algorithm=p["algo"], feedback=p["feedback"]/7.0, algo_source="0,1,2,3,4,5", envelope="0,0,1.0,1000", adsr_target=amy.TARGET_AMP)



def play_patch(patch_number, midinote=50, length_s = 2, keyup_s = 1):
	dx7_patch = dx7.unpack(patch_number)
	p = decode_patch(dx7_patch)
	print(str(p["name"]))
	setup_patch(p,midinote)

	amy.note_on(osc=6,vel=4)
	us_samples0 = amy.render(keyup_s)
	amy.note_off(osc=6)
	us_samples1 = amy.render(length_s - keyup_s)
	us_samples = np.hstack((us_samples0, us_samples1))

	them_samples = dx7_render(patch_number, midinote, 90, int(length_s*amy.SAMPLE_RATE),int(keyup_s*amy.SAMPLE_RATE))
	#fig, (s0,s1) = plt.subplots(2,1)
	#s0.specgram(us_samples, NFFT=512, Fs=amy.SAMPLE_RATE)
	#s1.specgram(them_samples, NFFT=512, Fs=amy.SAMPLE_RATE)
	#fig.show()
	print("AMY:")
	amy.play(us_samples)
	time.sleep(length_s)
	# A/B against MSFA 
	time.sleep(0.25)
	print("MSFA:")
	amy.play(them_samples)
	time.sleep(length_s)
	return p

def get_patch(patch_number):
	# returns a patch (as in patches.h) from 
    # unpacked.bin generated by dx7db, see https://github.com/bwhitman/learnfm
    f = bytes(open("unpacked.bin", mode="rb").read())
    patch_data = f[patch_number*156:patch_number*156+156]
    #name = ''.join([i if (ord(i) < 128 and ord(i) > 31) else ' ' for i in str(patch_data[145:155])])
    return patch_data

def decode_patch(p):
	def eg_to_adsr_amp(egrate, eglevel):
		def rate_to_ms(rate):
			return (99-rate)*2.5 # 250ms is rate=0, 0ms is rate=99
		# http://www.audiocentralmagazine.com/wp-content/uploads/2012/04/dx7-envelope.png
		# rate seems to be "speed", so higher rate == less time
		# NO idea what the time units are, so going to have to fudge this a bit
		# level is probably exp, but so is our ADSR? 
		(r1,r2,r3,r4) = egrate
		(l1,l2,l3,l4) = eglevel
		A = rate_to_ms(r1)
		D = rate_to_ms(r2) + rate_to_ms(r3)
		R = rate_to_ms(r4)
		S = l3/99.0
		amp = l1 / 99.0
		# we ignore l2 and l4 -- l4 should be 0, and l2 is that weird elbow
		# amp tbh is not really fair here , maybe for the carrier? 
		return ("%d,%d,%f,%d" % (A,D,S,R), amp)


	def output_level_to_amp(byte):
		# Sure could be a exp curve but seems a bit custom
		# https://i.stack.imgur.com/1FQqR.jpg
		if(byte<20): return 0
		if(byte<40): return 0.1/14
		if(byte<50): return 0.25/14
		if(byte<60): return 0.5/14
		if(byte<70): return 1.2/14
		if(byte<80): return 2.75/14
		if(byte<85): return 4./14
		if(byte<90): return 6./14
		if(byte<88): return 6.05/14
		if(byte<89): return 6.1/14
		if(byte<90): return 6.2/14
		if(byte<91): return 6.5/14
		if(byte<92): return 7./14
		if(byte<93): return 8./14
		if(byte<94): return 9./14
		if(byte<95): return 9.5/14
		if(byte<96): return 10./14
		if(byte<97): return 11./14
		if(byte<98): return 12.5/14
		if(byte<99): return 13./14
		return 1.0

	def lfo_wave(byte):
		if(byte == 0): return "triangle"
		if(byte == 1): return "ramp_down"
		if(byte == 2): return "ramp_up"
		if(byte == 3): return "pulse"
		if(byte == 4): return "sine"
		if(byte == 5): return "samplehold"
		return "unknown"
	def curve(byte):
		if(byte==0): return "-lin"
		if(byte==1): return "-exp"
		if(byte==2): return "+exp"
		if(byte==3): return "+lin"
		return "unknown"
	def coarse_fine_fixed_hz(coarse, fine):
		coarse = coarse & 3 # so many are > 3 (7500 out of 38K.) msfa cuts it like this, not sure whats' up here. maybe the knob loops over? 
		if(coarse==0):
			return 1 + ((fine / 10.0) )
		if(coarse==1):
			return 10 + (fine  )
		if(coarse==2):
			return 100 + ((fine * 10) )
		if(coarse==3):
			return 1000 + ((fine * 100.0) )
		print("fixed coarse > 3, is %d" % (coarse))
		return 0
	def coarse_fine_ratio(coarse,fine):
		if(coarse==0):
			return 0.5 + ((fine/200.0) - 0.5)
		coarse = coarse & 31 # see above
		return coarse + (fine/100.0)
		

	patch = {}
	ops = []
	# Starts at op 6
	c = 0
	for i in range(6):
		op = {}
		op["rate"] = [x for x in p[c:c+4]]
		op["level"] =  [x for x in p[c+4:c+8]]
		(op["envelope"], op["amp"]) = eg_to_adsr_amp([x for x in p[c:c+4]], [x for x in p[c+4:c+8]])
		c = c + 8
		op["brkpt"] = p[c]
		c = c + 1
		op["leftrightcurves"] = [x for x in p[c:c+4]]
		c = c + 4
		op["kbdratescaling"] = p[c]
		c = c + 1
		op["ampmodsens"] = p[c]
		c = c + 1
		op["keyvelsens"] = p[c]
		c = c + 1
		op["opamp"] = output_level_to_amp(p[c])
		c = c + 1
		if(p[c] == 1): # fixed
			op["fixedhz"] = coarse_fine_fixed_hz(p[c+1], p[c+2])
		else:
			op["ratio"] = coarse_fine_ratio(p[c+1], p[c+2])
		op["coarse"] = p[c+1]
		op["fine"] = p[c+2]
		c = c + 3
		op["detunehz"] = p[c] - 7
		c = c + 1
		ops.append(op)
	ops.reverse() # start from op 1
	patch["ops"] = ops
	patch["pitcheg"] = [x for x in p[c:c+8]]
	c = c + 8
	patch["algo"] = p[c]
	c = c + 1
	patch["feedback"] = p[c]
	c = c + 1
	patch["oscsync"] = p[c]
	c = c + 1
	patch["lfospeed"] = p[c]
	c = c + 1
	patch["lfodelay"] = p[c]
	c = c + 1
	patch["lfopitchmoddepth"] = p[c]
	c = c + 1
	patch["lfoampmoddepth"] = p[c]
	c = c + 1
	patch["lfosync"] = p[c]
	c = c + 1
	patch["lfowaveform"] = lfo_wave(p[c])
	c = c + 1
	patch["pitchmodsens"] = p[c]
	c = c + 1
	patch["transpose"] = p[c]
	c = c + 1
	patch["name"] =  ''.join(chr(i) for i in p[c:c+10])
	c = c + 10
	return patch



